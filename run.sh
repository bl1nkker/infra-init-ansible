#!/bin/bash
#
# ARG_OPTIONAL_SINGLE([tag],[t],[tag to execute])
# ARG_OPTIONAL_REPEATED([environment],[e],[pass ansible environment variable])
# ARG_POSITIONAL_SINGLE([script],[script to run],[])
# ARG_HELP([The general script's help msg])
# ARGBASH_GO()
# Generated online by https://argbash.io/generate


die()
{
    local _ret="${2:-1}"
    test "${_PRINT_HELP:-no}" = yes && print_help >&2
    echo "$1" >&2
    exit "${_ret}"
}


begins_with_short_option()
{
    local first_option all_short_options='bteh'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_become="off"
_arg_tag=
_arg_environment=()


print_help()
{
    printf '%s\n' "The general script's help msg"
    printf 'Usage: %s [-b|--(no-)become] [-t|--tag <arg>] [-e|--environment <arg>] [-h|--help] <script>\n' "$0"
    printf '\t%s\n' "<script>: script to run"
    printf '\t%s\n' "-b, --become, --no-become: become sudo (off by default)"
    printf '\t%s\n' "-t, --tag: tag to execute (no default)"
    printf '\t%s\n' "-e, --environment: pass ansible environment variable (empty by default)"
    printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
    _positionals_count=0
    while test $# -gt 0
    do
        _key="$1"
        case "$_key" in
            -b|--no-become|--become)
                _arg_become="on"
                test "${1:0:5}" = "--no-" && _arg_become="off"
                ;;
            -b*)
                _arg_become="on"
                _next="${_key##-b}"
                if test -n "$_next" -a "$_next" != "$_key"
                then
                    { begins_with_short_option "$_next" && shift && set -- "-b" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
                fi
                ;;
            -t|--tag)
                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                _arg_tag="$2"
                shift
                ;;
            --tag=*)
                _arg_tag="${_key##--tag=}"
                ;;
            -t*)
                _arg_tag="${_key##-t}"
                ;;
            -e|--environment)
                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                _arg_environment+=("$2")
                shift
                ;;
            --environment=*)
                _arg_environment+=("${_key##--environment=}")
                ;;
            -e*)
                _arg_environment+=("${_key##-e}")
                ;;
            -h|--help)
                print_help
                exit 0
                ;;
            -h*)
                print_help
                exit 0
                ;;
            *)
                _last_positional="$1"
                _positionals+=("$_last_positional")
                _positionals_count=$((_positionals_count + 1))
                ;;
        esac
        shift
    done
}


handle_passed_args_count()
{
    local _required_args_string="'script'"
    test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
    test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
    local _positional_name _shift_for=$1
    _positional_names="_arg_script "

    shift "$_shift_for"
    for _positional_name in ${_positional_names}
    do
        test $# -gt 0 || break
        eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
        shift
    done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])

env_placeholder=""
for env in "${_arg_environment[@]}"
do
    env_placeholder+="-e $env "
done

tags_placeholder=""
if [ ! -z "$_arg_tag" ]; then
    tags_placeholder="--tags=$_arg_tag"
fi

set -eu

run_as_root="False"
become_placeholder=""
if [ "$_arg_become" = "on" ]; then
    run_as_root="True"
    become_placeholder="-K"
fi

ansible-playbook $become_placeholder -v $tags_placeholder $env_placeholder -e run_as_root=$run_as_root playbooks/$_arg_script.yml